name: Build and Deploy

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # 수동 실행도 가능하도록

env:
  DOCKER_IMAGE: gilhwanjeon/smw-app
  DOCKER_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.DOCKER_IMAGE }}
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ github.run_number }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:latest
        cache-to: type=inline

  deploy-to-k8s:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # SSH 키를 파일로 저장 (멀티라인 처리)
        # 개행 문자 제거 및 형식 정리
        echo "${{ secrets.EC2_SSH_KEY }}" | tr -d '\r' > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
        # SSH 키 형식 검증
        echo "=== SSH 키 검증 ==="
        head -1 ~/.ssh/ec2_key
        if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/ec2_key; then
          echo "ERROR: SSH 키 형식이 올바르지 않습니다."
          exit 1
        fi
        
        # EC2 호스트 키 추가 (재시도 로직 포함)
        echo "=== EC2 호스트 키 추가 ==="
        for i in {1..5}; do
          if ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>&1; then
            echo "호스트 키 추가 성공"
            break
          else
            echo "호스트 키 추가 실패, 재시도 $i/5..."
            sleep 2
          fi
        done
        
        # SSH 연결 테스트
        echo "=== SSH 연결 테스트 ==="
        for i in {1..3}; do
          if ssh -i ~/.ssh/ec2_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=3 \
            ubuntu@${{ secrets.EC2_HOST }} \
            "echo 'SSH 연결 성공'" 2>&1; then
            echo "SSH 연결 테스트 성공"
            break
          else
            echo "SSH 연결 테스트 실패, 재시도 $i/3..."
            sleep 5
            if [ $i -eq 3 ]; then
              echo "ERROR: SSH 연결에 실패했습니다."
              exit 1
            fi
          fi
        done

    - name: Deploy to Kubernetes via SSH
      # 타임아웃 제거 (배포 작업이 완료될 때까지 대기)
      # timeout-minutes: 20
      run: |
        ssh -i ~/.ssh/ec2_key \
          -o StrictHostKeyChecking=no \
          -o UserKnownHostsFile=~/.ssh/known_hosts \
          -o ConnectTimeout=30 \
          -o ServerAliveInterval=30 \
          -o ServerAliveCountMax=10 \
          -o TCPKeepAlive=yes \
          -o BatchMode=yes \
          ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
          # set -e 제거 (일부 명령어 실패해도 계속 진행)
          cd ~/SMWR_WAS || { echo "ERROR: SMWR_WAS 디렉토리로 이동 실패"; exit 1; }
          
          # Git 저장소 설정 (없는 경우)
          if [ ! -d .git ]; then
            echo "=== Git 저장소 초기화 ==="
            git init || echo "Git init 실패 (무시)"
            git remote add origin https://github.com/jgh9514/SMWR_WAS.git 2>/dev/null || \
            git remote set-url origin https://github.com/jgh9514/SMWR_WAS.git 2>/dev/null || \
            echo "Git remote 설정 실패 (무시)"
          fi
          
          # 최신 코드 가져오기 (재시도 로직 포함, 실패해도 계속 진행)
          echo "=== 최신 코드 가져오기 ==="
          GIT_FETCH_SUCCESS=false
          for i in {1..5}; do
            if timeout 30 git fetch origin main 2>&1; then
              echo "Git fetch 성공"
              GIT_FETCH_SUCCESS=true
              break
            else
              echo "Git fetch 실패, 재시도 $i/5... (5초 대기)"
              sleep 5
            fi
          done
          
          # 로컬 브랜치 업데이트 (fetch가 성공한 경우만)
          if [ "$GIT_FETCH_SUCCESS" = "true" ] && git rev-parse --verify origin/main >/dev/null 2>&1; then
            echo "=== 로컬 브랜치 업데이트 ==="
            git reset --hard origin/main 2>&1 || \
            git checkout -B main origin/main 2>&1 || \
            echo "WARNING: Git reset 실패, 기존 코드 사용"
          else
            echo "WARNING: Git fetch 실패 또는 origin/main 브랜치를 찾을 수 없음, 기존 코드 사용"
          fi
          
          # 현재 Git 상태 확인
          echo "=== 현재 Git 상태 ==="
          git log --oneline -1 2>/dev/null || echo "Git 로그 확인 실패"
          git status --short 2>/dev/null || echo "Git 상태 확인 실패"
          
          # kubeconfig 설정 확인 및 수정
          mkdir -p ~/.kube
          
          # K3s kubeconfig 파일 찾기 및 복사
          if [ -f /etc/rancher/k3s/k3s.yaml ]; then
            sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
            sudo chown ubuntu:ubuntu ~/.kube/config
            # server 주소를 EC2 인스턴스의 내부 IP로 변경
            SERVER_IP=$(hostname -I | awk '{print $1}')
            sed -i "s|server: https://127.0.0.1:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config || \
            sed -i "s|server: https://localhost:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config
          elif [ -f /root/.kube/config ]; then
            sudo cp /root/.kube/config ~/.kube/config
            sudo chown ubuntu:ubuntu ~/.kube/config
            SERVER_IP=$(hostname -I | awk '{print $1}')
            sed -i "s|server: https://127.0.0.1:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config || \
            sed -i "s|server: https://localhost:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config
          else
            echo "ERROR: kubeconfig 파일을 찾을 수 없습니다."
            echo "K3s 클러스터가 설치되어 있는지 확인하세요."
            exit 1
          fi
          
          # KUBECONFIG 환경 변수 설정
          export KUBECONFIG=~/.kube/config
          
          # K3s 클러스터 상태 확인 (호스트 이름 해석 오류 무시)
          echo "=== K3s 클러스터 상태 확인 ==="
          # 호스트 이름 해석 오류를 무시하기 위해 환경 변수 설정
          export DEBIAN_FRONTEND=noninteractive
          sudo systemctl status k3s --no-pager 2>/dev/null | head -5 || echo "K3s 서비스 상태 확인 실패 (무시)"
          
          # kubectl이 작동하는지 확인
          echo "=== kubectl 클러스터 정보 확인 ==="
          kubectl cluster-info --request-timeout=10s || {
            echo "kubectl cluster-info 실패, kubeconfig 확인 중..."
            cat ~/.kube/config | grep -A 2 "server:" || echo "kubeconfig 파일 내용 확인 실패"
            exit 1
          }
          
          # kubectl 버전 및 노드 확인
          kubectl version --client --request-timeout=10s || echo "kubectl version 확인 실패"
          kubectl get nodes --request-timeout=10s || {
            echo "노드 확인 실패"
            exit 1
          }
          
          # 최신 이미지로 업데이트
          echo "=== 이미지 태그 업데이트 ==="
          if [ -f k8s/deployment.yaml ]; then
            sed -i 's|image: gilhwanjeon/smw-app:.*|image: gilhwanjeon/smw-app:latest|g' k8s/deployment.yaml
            echo "이미지 태그 업데이트 완료"
          else
            echo "WARNING: k8s/deployment.yaml 파일을 찾을 수 없음"
          fi
          
          # 백엔드 배포
          echo "=== 배포 시작 ==="
          if [ -f k8s/deployment.yaml ]; then
            kubectl apply -f k8s/deployment.yaml --request-timeout=60s || {
              echo "배포 실패, 재시도 중..."
              sleep 5
              kubectl apply -f k8s/deployment.yaml --request-timeout=60s || {
                echo "ERROR: 배포 실패"
                exit 1
              }
            }
          else
            echo "ERROR: k8s/deployment.yaml 파일이 없습니다."
            exit 1
          fi
          
          # Pod 재시작 (배포가 이미 존재하는 경우)
          echo "=== Pod 재시작 ==="
          kubectl rollout restart deployment/smw-app --request-timeout=60s 2>/dev/null || \
          kubectl delete pod -l app=smw-app --request-timeout=60s 2>/dev/null || \
          echo "Pod 재시작 스킵 (새 배포일 수 있음)"
          
          # 배포 상태 확인
          echo "=== 배포 상태 확인 ==="
          kubectl get pods --request-timeout=30s || {
            echo "WARNING: Pod 상태 확인 실패"
          }
          kubectl get services --request-timeout=30s || {
            echo "WARNING: Service 상태 확인 실패"
          }
          
          # 배포 완료 대기 (최소 대기)
          echo "=== 배포 완료 대기 (5초) ==="
          sleep 5
          
          # 최종 상태 확인
          echo "=== 최종 배포 상태 ==="
          kubectl get pods -l app=smw-app --request-timeout=30s || echo "Pod 상태 확인 실패 (무시)"
          
          # Pod 로그 확인 (최근 5줄만, 빠르게)
          echo "=== Pod 로그 확인 (최근 5줄) ==="
          POD_NAME=$(kubectl get pods -l app=smw-app -o jsonpath='{.items[0].metadata.name}' --request-timeout=15s 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ] && [ "$POD_NAME" != "null" ]; then
            kubectl logs --tail=5 $POD_NAME --request-timeout=15s 2>/dev/null || echo "로그 확인 실패 (무시)"
          else
            echo "Pod를 찾을 수 없습니다. (무시)"
          fi
          
          echo "=== 배포 작업 완료 ==="
        EOF


