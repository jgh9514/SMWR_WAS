name: Build and Deploy

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # 수동 실행도 가능하도록

env:
  DOCKER_IMAGE: gilhwanjeon/smw-app
  DOCKER_TAG: ${{ github.sha }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Build with Maven
      run: mvn clean package -DskipTests

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.DOCKER_IMAGE }}
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ github.run_number }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:latest
        cache-to: type=inline

  deploy-to-k8s:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure SSH
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # SSH 키를 파일로 저장 (멀티라인 처리)
        # 개행 문자 제거 및 형식 정리
        echo "${{ secrets.EC2_SSH_KEY }}" | tr -d '\r' > ~/.ssh/ec2_key
        chmod 600 ~/.ssh/ec2_key
        
        # SSH 키 형식 검증
        echo "=== SSH 키 검증 ==="
        head -1 ~/.ssh/ec2_key
        if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/ec2_key; then
          echo "ERROR: SSH 키 형식이 올바르지 않습니다."
          exit 1
        fi
        
        # EC2 호스트 키 추가 (재시도 로직 포함)
        echo "=== EC2 호스트 키 추가 ==="
        for i in {1..5}; do
          if ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>&1; then
            echo "호스트 키 추가 성공"
            break
          else
            echo "호스트 키 추가 실패, 재시도 $i/5..."
            sleep 2
          fi
        done
        
        # SSH 연결 테스트
        echo "=== SSH 연결 테스트 ==="
        for i in {1..3}; do
          if ssh -i ~/.ssh/ec2_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=10 \
            -o ServerAliveInterval=60 \
            -o ServerAliveCountMax=3 \
            ubuntu@${{ secrets.EC2_HOST }} \
            "echo 'SSH 연결 성공'" 2>&1; then
            echo "SSH 연결 테스트 성공"
            break
          else
            echo "SSH 연결 테스트 실패, 재시도 $i/3..."
            sleep 5
            if [ $i -eq 3 ]; then
              echo "ERROR: SSH 연결에 실패했습니다."
              exit 1
            fi
          fi
        done

    - name: Deploy to Kubernetes via SSH
      timeout-minutes: 15
      run: |
        ssh -i ~/.ssh/ec2_key \
          -o StrictHostKeyChecking=no \
          -o UserKnownHostsFile=~/.ssh/known_hosts \
          -o ConnectTimeout=30 \
          -o ServerAliveInterval=30 \
          -o ServerAliveCountMax=10 \
          -o TCPKeepAlive=yes \
          -o BatchMode=yes \
          ubuntu@${{ secrets.EC2_HOST }} << 'EOF'
          set -e
          cd ~/SMWR_WAS
          
          # Git 저장소 설정 (없는 경우)
          if [ ! -d .git ]; then
            git init
            git remote add origin https://github.com/jgh9514/SMWR_WAS.git || true
            git fetch origin
            git checkout -b main origin/main || git reset --hard origin/main
          fi
          
          # 최신 코드 가져오기
          git pull origin main || git fetch origin && git reset --hard origin/main
          
          # kubeconfig 설정 확인 및 수정
          mkdir -p ~/.kube
          
          # K3s kubeconfig 파일 찾기 및 복사
          if [ -f /etc/rancher/k3s/k3s.yaml ]; then
            sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
            sudo chown ubuntu:ubuntu ~/.kube/config
            # server 주소를 EC2 인스턴스의 내부 IP로 변경
            SERVER_IP=$(hostname -I | awk '{print $1}')
            sed -i "s|server: https://127.0.0.1:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config || \
            sed -i "s|server: https://localhost:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config
          elif [ -f /root/.kube/config ]; then
            sudo cp /root/.kube/config ~/.kube/config
            sudo chown ubuntu:ubuntu ~/.kube/config
            SERVER_IP=$(hostname -I | awk '{print $1}')
            sed -i "s|server: https://127.0.0.1:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config || \
            sed -i "s|server: https://localhost:6443|server: https://${SERVER_IP}:6443|g" ~/.kube/config
          else
            echo "ERROR: kubeconfig 파일을 찾을 수 없습니다."
            echo "K3s 클러스터가 설치되어 있는지 확인하세요."
            exit 1
          fi
          
          # KUBECONFIG 환경 변수 설정
          export KUBECONFIG=~/.kube/config
          
          # K3s 클러스터 상태 확인
          echo "=== K3s 클러스터 상태 확인 ==="
          sudo systemctl status k3s --no-pager || echo "K3s 서비스 상태 확인 실패"
          
          # kubectl이 작동하는지 확인
          echo "=== kubectl 클러스터 정보 확인 ==="
          kubectl cluster-info --request-timeout=10s || {
            echo "kubectl cluster-info 실패, kubeconfig 확인 중..."
            cat ~/.kube/config | grep -A 2 "server:" || echo "kubeconfig 파일 내용 확인 실패"
            exit 1
          }
          
          # kubectl 버전 및 노드 확인
          kubectl version --client --request-timeout=10s || echo "kubectl version 확인 실패"
          kubectl get nodes --request-timeout=10s || {
            echo "노드 확인 실패"
            exit 1
          }
          
          # 최신 이미지로 업데이트
          sed -i 's|image: gilhwanjeon/smw-app:.*|image: gilhwanjeon/smw-app:latest|g' k8s/deployment.yaml
          
          # 백엔드 배포
          echo "=== 배포 시작 ==="
          kubectl apply -f k8s/deployment.yaml --request-timeout=30s || {
            echo "배포 실패, 재시도 중..."
            kubectl apply -f k8s/deployment.yaml --request-timeout=30s || exit 1
          }
          
          # Pod 재시작 (배포가 이미 존재하는 경우)
          echo "=== Pod 재시작 ==="
          kubectl rollout restart deployment/smw-app --request-timeout=30s 2>/dev/null || \
          kubectl delete pod -l app=smw-app --request-timeout=30s 2>/dev/null || \
          echo "Pod 재시작 스킵 (새 배포일 수 있음)"
          
          # 배포 상태 확인
          echo "=== 배포 상태 확인 ==="
          kubectl get pods --request-timeout=10s || exit 1
          kubectl get services --request-timeout=10s || exit 1
          
          # 배포 완료 대기 (단축)
          echo "=== 배포 완료 대기 (10초) ==="
          sleep 10
          
          # 최종 상태 확인
          echo "=== 최종 배포 상태 ==="
          kubectl get pods --request-timeout=10s || exit 1
          
          # Pod 로그 확인 (최근 10줄만, 빠르게)
          echo "=== Pod 로그 확인 (최근 10줄) ==="
          POD_NAME=$(kubectl get pods -l app=smw-app -o jsonpath='{.items[0].metadata.name}' --request-timeout=10s 2>/dev/null || echo "")
          if [ -n "$POD_NAME" ]; then
            kubectl logs --tail=10 $POD_NAME --request-timeout=10s 2>/dev/null || echo "로그 확인 실패 (무시)"
          else
            echo "Pod를 찾을 수 없습니다."
          fi
          
          echo "=== 배포 완료 ==="
        EOF


